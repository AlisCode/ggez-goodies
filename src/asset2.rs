//! An experimental asset loader loosely based off
//! of a ggez-ified version of Amethyst's asset loader:
//!
//! https://docs.rs/amethyst/0.4.3/amethyst/asset_manager/index.html
//!
//! The main difference from Amethyst is it doesn't store things in specs;
//! the main difference from the existing asset loader is its storage of
//! assets in anymap's.

use std::collections::HashMap;
use std::any::{Any, TypeId};
use ggez;

pub type AssetId = usize;

pub struct AssetCache {
    //loaders: HashMap<TypeId, Box<FnMut(Box<Any>)>>,//Box<AssetLoader<Box<Any>>>>,
    loaders: HashMap<TypeId, Box<AssetLoader<Asset=usize>>>,
    asset_ids: HashMap<String, AssetId>,
    assets: Vec<Box<Any>>,
}

/// Describes an abstract asset loader type.
///
/// This is what Amethyst uses but is weirdly not-what-we-want for
/// this application, so idk.
pub trait AssetLoader {
    type Asset;
    fn from_data(assets: &mut AssetCache, data: Self) -> Self::Asset;
}

/// This isn't what we want either though, apparently.  So!
//pub type AssetLoader<A> = Fn(&mut ggez::Context, &str) -> ggez::GameResult<A>;

impl AssetCache {
    pub fn new() -> Self {
        Self {
            loaders: HashMap::new(),
            asset_ids: HashMap::new(),
            assets: Vec::new(),
        }
    }
    
    pub fn add_loader(&mut self, loader: Box<AssetLoader<Asset=usize>>) {
        //let loader = Box::new(loader);
        self.loaders.insert(TypeId::of::<T>(), loader as Box<AssetLoader<Box<Any>>>);
    }

    /// Load an asset from data
    pub fn load_asset_from_data<A>(&mut self,
                                   ctx: &mut ggez::Context,
                                   name: &str)
                                   -> ggez::GameResult<AssetId>
        where A: Any
    {
        //let asset = AssetLoader::<A, E>::from_data(self, data)?;
        let asset = {
            let loader = self.loaders.get(&TypeId::of::<A>()).unwrap();
            loader(ctx, name)?;
        };
        let id = self.add_asset(name, asset);
        Ok(id)
    }

    pub fn id_from_name(&self, name: &str) -> Option<AssetId> {
        self.asset_ids.get(name).map(|id| *id)
    }

    pub fn get<T>(&self, id: AssetId) -> Option<&T>
        where T: 'static
    {
        self.assets.get(id)
            .map(|itm| &**itm)
            .and_then(|itm| itm.downcast_ref::<T>())
    }

    fn add_asset(&mut self, name: &str, asset: usize) -> AssetId {
        self.assets.push(Box::new(asset));
        let id = self.assets.len();
        self.asset_ids
            .entry(name.into())
            .or_insert(id);
        id
    }
}
/*
fn extension_matches(path: &path::Path, ext: &str) -> bool {
    if let Some(extension) = path.extension() {
        extension.to_str().unwrap() == ext
    } else {
        false
    }
}


fn get_file_name(path: &path::Path) -> Option<&str> {
    path.file_name().map(|name| name.to_str().unwrap())
}

/// This macro takes an identifier, names for the load and get functions to create,
/// as well as a type and a function to load that particular type, and constructs
/// a structure that contains caches for those assets types and functions to get
/// them.
///
/// Yes we could just use an AnyMap and a trait, but that's quitter talk.  We want
/// MAX PERFORMANCE for this 1989-era non-real-time game!
///
/// TODO: Make a variant with an optional file extension, and construct a function
/// that pre-loads all those files!
macro_rules! assets {
    ($($name:ident, $load_name: ident, $get_name:ident: $t:ty => 
        $loader:path, $ext:expr, $path:expr),*) => {
        pub struct Assets {
            $(
                $name: RwLock<HashMap<String,Rc<$t>>>,
            )*
        }

        impl Assets {
            pub fn new(ctx: &mut Context) -> GameResult<Self> {
                let assets = Assets {
                    $(
                        $name: RwLock::new(HashMap::new()),
                    )*
                };
                // Pre-load all assets
                assets.load_files(ctx);
                Ok(assets)
            }

            // BUGGO: This should be generated by macro :/
            // Or by some even better method.
            // The main problem there is that suddenly we need to 
            // have TWO more pieces of information in the macro, 
            // the file extension and directory name.
            // this is starting to get unwieldy and maybe 
            // there's a better way of generalizing it.
            fn load_files(&self, ctx: &mut Context) {
                $(
                for path in ctx.filesystem.read_dir($path).unwrap().iter() {
                    // println!("Loading image {:?}", path);
                    if extension_matches(&path, $ext) {
                        if let Some(fname) = get_file_name(&path) {
                            info!(log::LOG, "Loading {}/{}", $path, fname);
                            self.$load_name(ctx, fname);
                        }
                    } else {
                        warn!(log::LOG, "Warning: Unknown file type: {:?}", path);
                    }
                }
                )*
            }

            $(
                pub fn $load_name(&self, ctx: &mut Context, name: &str) -> Rc<$t> {
                    let loader = || Rc::new($loader(ctx, self, name));
                    let map = &mut *self.$name.write().unwrap();
                    let value = map.entry(name.to_string()).or_insert_with(loader);
                    (*value).clone()
                }
                
                pub fn $get_name(&self, name: &str) -> Rc<$t> {
                    let message = format!("Could not get asset \"{}\"", name);
                    let map = self.$name.read().unwrap();
                    (*map.get(name).expect(&message)).clone()
                }

            )*
        }
    }
}

fn image_loader(ctx: &mut Context, _assets: &Assets, name: &str) -> graphics::Image {
    // println!("Loading {}", name);
    let path = "/images/".to_string() + name;
    let msg = format!("Could not load image {}, expected path {:?}", name, path);
    graphics::Image::new(ctx, &path).expect(&msg)
}



fn font_loader(ctx: &mut Context, _assets: &Assets, name: &str) -> graphics::Font {
    // println!("Loading {}", name);
    let path = "/fonts/".to_string() + name;
    let msg = format!("Could not load font {}, expected path {:?}", name, path);
    graphics::Font::new(ctx, &path, 20).expect(&msg)
}

fn sprite_loader(ctx: &mut Context, _assets: &Assets, name: &str) -> aseprite::SpritesheetData {

    let path = "/sprites/".to_string() + name;
    let msg = format!("Could not open file for sprite {}, expected path {:?}",
                      name,
                      path);
    let f = ctx.filesystem.open(&path).expect(&msg);
    let msg = format!("Got invalid data for sprite {}", name);
    let spritedata: aseprite::SpritesheetData = serde_json::from_reader(f).expect(&msg);
    spritedata
}

fn tilemap_loader(ctx: &mut Context, _assets: &Assets, name: &str) -> tiled::Map {
    let path = "/maps/".to_string() + name;
    let msg = format!("Could not open file for map {}, expected path {:?}",
                      name,
                      path);
    let mut f = ctx.filesystem.open(path).expect(&msg);
    let buf = &mut Vec::new();
    f.read_to_end(buf)
        .expect(&format!("Could not read map file {}?!", name));
    tiled::parse(&**buf).expect(&format!("Invalid map file {}?!", name))
}

fn conversation_loader(ctx: &mut Context, _assets: &Assets, name: &str) -> conversation::ConversationEngine {
    // println!("Loading {}", name);
    let path = "/conv/".to_string() + name;
    let msg = format!("Could not open file for map {}, expected path {:?}",
                      name,
                      path);
    let mut f = ctx.filesystem.open(path).expect(&msg);
    let text = &mut String::new();
    let _ = f.read_to_string(text).expect("Could not read conversation?");
    conversation::ConversationEngine::from_str(&text).expect("Syntax error in conversation?")
}






assets! [
    images, load_image, get_image: graphics::Image => image_loader, "png", "/images",
    fonts, load_font, get_font: graphics::Font => font_loader, "ttf", "/fonts",
    tilemaps, load_tilemap, get_tilemap: tiled::Map => tilemap_loader, "tmx", "/maps",
    sprites, load_sprite, get_sprite: aseprite::SpritesheetData => sprite_loader, "json", "/sprites",
    conversations, load_conversation, get_conversation: conversation::ConversationEngine => conversation_loader, "pjson", "/conv"
];
*/

#[cfg(test)]
mod tests {
    use super::*;

    #[derive(Clone, Debug, Hash, PartialEq)]
    struct DummyImage(usize);
    #[derive(Clone, Debug, Hash, PartialEq)]
    struct DummyImageData;
    impl AssetLoader<DummyImage, ()> for DummyImageData {
        fn from_data(assets: &mut AssetCache, data: Self) -> Result<DummyImage, ()> {
            Ok(DummyImage(1))
        }
    }

    #[test]
    fn test_loading() {
        let mut cache = AssetCache::new();
        cache.add_loader(DummyImageData);
        let id = cache.load_asset_from_data("foo", DummyImageData).unwrap();
        //let itm = cache.get::<DummyImageData>(id).unwrap();
        //assert_eq!(itm, &DummyImage(1));
    }
}
